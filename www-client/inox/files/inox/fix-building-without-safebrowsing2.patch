--- ./chrome/browser/browser_process.h
+++ ./chrome/browser/browser_process.h.new
@@ -42,10 +42,6 @@ class WatchDogThread;
 class WebRtcLogUploader;
 #endif

-namespace safe_browsing {
-class SafeBrowsingService;
-}
-
 namespace subresource_filter {
 class RulesetService;
 }
@@ -111,10 +107,6 @@ namespace rappor {
 class RapporService;
 }

-namespace safe_browsing {
-class ClientSideDetectionService;
-}
-
 // NOT THREAD SAFE, call only from the main thread.
 // These functions shouldn't return NULL unless otherwise noted.
 class BrowserProcess {
@@ -218,14 +210,6 @@ class BrowserProcess {
   // on this platform (or this is a unit test).
   virtual StatusTray* status_tray() = 0;

-  // Returns the SafeBrowsing service.
-  virtual safe_browsing::SafeBrowsingService* safe_browsing_service() = 0;
-
-  // Returns an object which handles communication with the SafeBrowsing
-  // client-side detection servers.
-  virtual safe_browsing::ClientSideDetectionService*
-      safe_browsing_detection_service() = 0;
-
   // Returns the service providing versioned storage for rules used by the Safe
   // Browsing subresource filter.
   virtual subresource_filter::RulesetService*
--- ./chrome/browser/ui/webui/md_downloads/md_downloads_dom_handler.h
+++ ./chrome/browser/ui/webui/md_downloads/md_downloads_dom_handler.h.new
@@ -12,7 +12,6 @@

 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/ui/webui/md_downloads/downloads_list_tracker.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_ui_message_handler.h"
@@ -104,9 +103,6 @@ class MdDownloadsDOMHandler : public content::WebContentsObserver,
   // dangerous ones are immediately removed. Protected for testing.
   void RemoveDownloads(const DownloadVector& to_remove);

-  // Helper function to handle save download event.
-  void SaveDownload(content::DownloadItem* download);
-
  private:
   using IdSet = std::set<uint32_t>;

@@ -118,19 +114,6 @@ class MdDownloadsDOMHandler : public content::WebContentsObserver,
   // null-checking |original_notifier_|.
   content::DownloadManager* GetOriginalNotifierManager() const;

-  // Displays a native prompt asking the user for confirmation after accepting
-  // the dangerous download specified by |dangerous|. The function returns
-  // immediately, and will invoke DangerPromptAccepted() asynchronously if the
-  // user accepts the dangerous download. The native prompt will observe
-  // |dangerous| until either the dialog is dismissed or |dangerous| is no
-  // longer an in-progress dangerous download.
-  virtual void ShowDangerPrompt(content::DownloadItem* dangerous);
-
-  // Conveys danger acceptance from the DownloadDangerPrompt to the
-  // DownloadItem.
-  virtual void DangerPromptDone(int download_id,
-                                DownloadDangerPrompt::Action action);
-
   // Returns true if the records of any downloaded items are allowed (and able)
   // to be deleted.
   bool IsDeletingHistoryAllowed();
--- ./chrome/browser/ui/webui/md_downloads/md_downloads_dom_handler.cc
+++ ./chrome/browser/ui/webui/md_downloads/md_downloads_dom_handler.cc.new
@@ -19,7 +19,6 @@
 #include "base/threading/thread.h"
 #include "base/values.h"
 #include "chrome/browser/browser_process.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/download/download_history.h"
 #include "chrome/browser/download/download_item_model.h"
 #include "chrome/browser/download/download_prefs.h"
@@ -193,34 +192,6 @@ void MdDownloadsDOMHandler::HandleDrag(const base::ListValue* args) {

 void MdDownloadsDOMHandler::HandleSaveDangerous(const base::ListValue* args) {
   CountDownloadsDOMEvents(DOWNLOADS_DOM_EVENT_SAVE_DANGEROUS);
-  content::DownloadItem* file = GetDownloadByValue(args);
-  SaveDownload(file);
-}
-
-void MdDownloadsDOMHandler::SaveDownload(
-    content::DownloadItem* download) {
-  if (!download)
-    return;
-  // If danger type is NOT DANGEROUS_FILE, chrome shows users a download danger
-  // prompt.
-  if (download->GetDangerType() !=
-      content::DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE) {
-    ShowDangerPrompt(download);
-  } else {
-    // If danger type is DANGEROUS_FILE, chrome proceeds to keep this download
-    // without showing download danger prompt.
-    if (profile_) {
-      PrefService* prefs = profile_->GetPrefs();
-      if (!profile_->IsOffTheRecord() &&
-          prefs->GetBoolean(prefs::kSafeBrowsingEnabled)) {
-        DownloadDangerPrompt::SendSafeBrowsingDownloadReport(
-            safe_browsing::ClientSafeBrowsingReportRequest::
-                DANGEROUS_DOWNLOAD_RECOVERY,
-            true, *download);
-      }
-    }
-    DangerPromptDone(download->GetId(), DownloadDangerPrompt::ACCEPT);
-  }
 }

 void MdDownloadsDOMHandler::HandleDiscardDangerous(
@@ -322,12 +293,6 @@ void MdDownloadsDOMHandler::RemoveDownloads(const DownloadVector& to_remove) {
   IdSet ids;

   for (auto* download : to_remove) {
-    if (download->IsDangerous()) {
-      // Don't allow users to revive dangerous downloads; just nuke 'em.
-      download->Remove();
-      continue;
-    }
-
     DownloadItemModel item_model(download);
     if (!item_model.ShouldShowInShelf() ||
         download->GetState() == content::DownloadItem::IN_PROGRESS) {
@@ -380,33 +345,6 @@ void MdDownloadsDOMHandler::FinalizeRemovals() {
   }
 }

-void MdDownloadsDOMHandler::ShowDangerPrompt(
-    content::DownloadItem* dangerous_item) {
-  DownloadDangerPrompt* danger_prompt = DownloadDangerPrompt::Create(
-      dangerous_item,
-      GetWebUIWebContents(),
-      false,
-      base::Bind(&MdDownloadsDOMHandler::DangerPromptDone,
-                 weak_ptr_factory_.GetWeakPtr(), dangerous_item->GetId()));
-  // danger_prompt will delete itself.
-  DCHECK(danger_prompt);
-}
-
-void MdDownloadsDOMHandler::DangerPromptDone(
-    int download_id, DownloadDangerPrompt::Action action) {
-  if (action != DownloadDangerPrompt::ACCEPT)
-    return;
-  content::DownloadItem* item = NULL;
-  if (GetMainNotifierManager())
-    item = GetMainNotifierManager()->GetDownload(download_id);
-  if (!item && GetOriginalNotifierManager())
-    item = GetOriginalNotifierManager()->GetDownload(download_id);
-  if (!item || item->IsDone())
-    return;
-  CountDownloadsDOMEvents(DOWNLOADS_DOM_EVENT_SAVE_DANGEROUS);
-  item->ValidateDangerousDownload();
-}
-
 bool MdDownloadsDOMHandler::IsDeletingHistoryAllowed() {
   content::DownloadManager* manager = GetMainNotifierManager();
   return manager &&
--- ./chrome/browser/extensions/api/downloads/downloads_api.cc
+++ ./chrome/browser/extensions/api/downloads/downloads_api.cc.new
@@ -35,7 +35,6 @@
 #include "base/values.h"
 #include "build/build_config.h"
 #include "chrome/browser/browser_process.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/download/download_file_icon_extractor.h"
 #include "chrome/browser/download/download_prefs.h"
 #include "chrome/browser/download/download_query.h"
@@ -1248,9 +1247,6 @@ DownloadsAcceptDangerFunction::DownloadsAcceptDangerFunction() {}

 DownloadsAcceptDangerFunction::~DownloadsAcceptDangerFunction() {}

-DownloadsAcceptDangerFunction::OnPromptCreatedCallback*
-    DownloadsAcceptDangerFunction::on_prompt_created_ = NULL;
-
 bool DownloadsAcceptDangerFunction::RunAsync() {
   std::unique_ptr<downloads::AcceptDanger::Params> params(
       downloads::AcceptDanger::Params::Create(*args_));
@@ -1285,40 +1281,7 @@ void DownloadsAcceptDangerFunction::PromptOrWait(int download_id, int retries) {
     return;
   }
   RecordApiFunctions(DOWNLOADS_FUNCTION_ACCEPT_DANGER);
-  // DownloadDangerPrompt displays a modal dialog using native widgets that the
-  // user must either accept or cancel. It cannot be scripted.
-  DownloadDangerPrompt* prompt = DownloadDangerPrompt::Create(
-      download_item,
-      web_contents,
-      true,
-      base::Bind(&DownloadsAcceptDangerFunction::DangerPromptCallback,
-                 this, download_id));
-  // DownloadDangerPrompt deletes itself
-  if (on_prompt_created_ && !on_prompt_created_->is_null())
-    on_prompt_created_->Run(prompt);
-  // Function finishes in DangerPromptCallback().
-}
-
-void DownloadsAcceptDangerFunction::DangerPromptCallback(
-    int download_id, DownloadDangerPrompt::Action action) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  DownloadItem* download_item =
-      GetDownload(browser_context(), include_incognito(), download_id);
-  if (InvalidId(download_item, &error_) ||
-      Fault(download_item->GetState() != DownloadItem::IN_PROGRESS,
-            errors::kNotInProgress, &error_))
-    return;
-  switch (action) {
-    case DownloadDangerPrompt::ACCEPT:
-      download_item->ValidateDangerousDownload();
-      break;
-    case DownloadDangerPrompt::CANCEL:
-      download_item->Remove();
-      break;
-    case DownloadDangerPrompt::DISMISS:
-      break;
-  }
-  SendResponse(error_.empty());
+  download_item->ValidateDangerousDownload();
 }

 DownloadsShowFunction::DownloadsShowFunction() {}
--- ./chrome/browser/extensions/api/downloads/downloads_api.h
+++ ./chrome/browser/extensions/api/downloads/downloads_api.h.new
@@ -13,7 +13,6 @@
 #include "base/scoped_observer.h"
 #include "base/time/time.h"
 #include "chrome/browser/download/all_download_item_notifier.h"
-#include "chrome/browser/download/download_danger_prompt.h"
 #include "chrome/browser/download/download_path_reservation_tracker.h"
 #include "chrome/browser/extensions/chrome_extension_function.h"
 #include "chrome/common/extensions/api/downloads.h"
@@ -193,25 +192,16 @@ class DownloadsRemoveFileFunction : public ChromeAsyncExtensionFunction {

 class DownloadsAcceptDangerFunction : public ChromeAsyncExtensionFunction {
  public:
-  typedef base::Callback<void(DownloadDangerPrompt*)> OnPromptCreatedCallback;
-  static void OnPromptCreatedForTesting(
-      OnPromptCreatedCallback* callback) {
-    on_prompt_created_ = callback;
-  }
-
   DECLARE_EXTENSION_FUNCTION("downloads.acceptDanger", DOWNLOADS_ACCEPTDANGER)
   DownloadsAcceptDangerFunction();
   bool RunAsync() override;

  protected:
   ~DownloadsAcceptDangerFunction() override;
-  void DangerPromptCallback(int download_id,
-                            DownloadDangerPrompt::Action action);

  private:
   void PromptOrWait(int download_id, int retries);

-  static OnPromptCreatedCallback* on_prompt_created_;
   DISALLOW_COPY_AND_ASSIGN(DownloadsAcceptDangerFunction);
 };

--- ./chrome/browser/download/download_prefs.cc
+++ ./chrome/browser/download/download_prefs.cc.new
@@ -49,7 +49,6 @@
 using content::BrowserContext;
 using content::BrowserThread;
 using content::DownloadManager;
-using safe_browsing::FileTypePolicies;

 namespace {

@@ -184,13 +183,7 @@ DownloadPrefs::DownloadPrefs(Profile* profile) : profile_(profile) {
         base::FilePath::StringType(1, base::FilePath::kExtensionSeparator) +
         extension);

-    // Note that the list of file types that are not allowed to open
-    // automatically can change in the future. When the list is tightened, it is
-    // expected that some entries in the users' auto open list will get dropped
-    // permanently as a result.
-    if (FileTypePolicies::GetInstance()->IsAllowedToOpenAutomatically(
-            filename_with_extension))
-      auto_open_.insert(extension);
+    auto_open_.insert(extension);
   }
 }

@@ -315,9 +308,6 @@ bool DownloadPrefs::IsAutoOpenEnabledBasedOnExtension(
 bool DownloadPrefs::EnableAutoOpenBasedOnExtension(
     const base::FilePath& file_name) {
   base::FilePath::StringType extension = file_name.Extension();
-  if (!FileTypePolicies::GetInstance()->IsAllowedToOpenAutomatically(
-          file_name))
-    return false;

   DCHECK(extension[0] == base::FilePath::kExtensionSeparator);
   extension.erase(0, 1);
--- ./chrome/browser/component_updater/file_type_policies_component_installer.cc
+++ ./chrome/browser/component_updater/file_type_policies_component_installer.cc.new
@@ -35,20 +35,6 @@ const uint8_t kPublicKeySHA256[32] = {
 const char kFileTypePoliciesManifestName[] = "File Type Policies";

 void LoadFileTypesFromDisk(const base::FilePath& pb_path) {
-  if (pb_path.empty())
-    return;
-
-  VLOG(1) << "Reading Download File Types from file: " << pb_path.value();
-  std::string binary_pb;
-  if (!base::ReadFileToString(pb_path, &binary_pb)) {
-    // The file won't exist on new installations, so this is not always an
-    // error.
-    VLOG(1) << "Failed reading from " << pb_path.value();
-    return;
-  }
-
-  safe_browsing::FileTypePolicies::GetInstance()->PopulateFromDynamicUpdate(
-      binary_pb);
 }

 }  // namespace
--- ./chrome/browser/download/download_target_determiner.cc
+++ ./chrome/browser/download/download_target_determiner.cc.new
@@ -892,29 +892,7 @@
        download_->HasUserGesture())
      return DownloadFileType::NOT_DANGEROUS;

-  DownloadFileType::DangerLevel danger_level =
-      safe_browsing::FileTypePolicies::GetInstance()->GetFileDangerLevel(
-          virtual_path_.BaseName());
-
-  // A danger level of ALLOW_ON_USER_GESTURE is used to label potentially
-  // dangerous file types that have a high frequency of legitimate use. We would
-  // like to avoid prompting for the legitimate cases as much as possible. To
-  // that end, we consider a download to be legitimate if one of the following
-  // is true, and avoid prompting:
-  //
-  // * The user navigated to the download URL via the omnibox (either by typing
-  //   the URL, pasting it, or using search).
-  //
-  // * The navigation that initiated the download has a user gesture associated
-  //   with it AND the user the user is familiar with the referring origin. A
-  //   user is considered familiar with a referring origin if a visit for a page
-  //   from the same origin was recorded on the previous day or earlier.
-  if (danger_level == DownloadFileType::ALLOW_ON_USER_GESTURE &&
-      ((download_->GetTransitionType() &
-        ui::PAGE_TRANSITION_FROM_ADDRESS_BAR) != 0 ||
-       (download_->HasUserGesture() && visits == VISITED_REFERRER)))
-    return DownloadFileType::NOT_DANGEROUS;
-  return danger_level;
+  return DownloadFileType::NOT_DANGEROUS;
 }

 void DownloadTargetDeterminer::OnDownloadDestroyed(
--- ./chrome/browser/permissions/permission_uma_util.cc
+++ ./chrome/browser/permissions/permission_uma_util.cc.new
@@ -608,8 +608,6 @@
             requesting_origin, permission, profile),
         PermissionDecisionAutoBlocker::GetIgnoreCount(
             requesting_origin, permission, profile));
-    g_browser_process->safe_browsing_service()
-        ->ui_manager()->ReportPermissionAction(report_info);
   }

   bool secure_origin = content::IsOriginSecure(requesting_origin);
--- ./chrome/browser/ssl/chrome_security_state_model_client.cc
+++ ./chrome/browser/ssl/chrome_security_state_model_client.cc.new
@@ -174,16 +174,6 @@ void AddConnectionExplanation(
 void CheckSafeBrowsingStatus(content::NavigationEntry* entry,
                              content::WebContents* web_contents,
                              SecurityStateModel::VisibleSecurityState* state) {
-  safe_browsing::SafeBrowsingService* sb_service =
-      g_browser_process->safe_browsing_service();
-  if (!sb_service)
-    return;
-  scoped_refptr<SafeBrowsingUIManager> sb_ui_manager = sb_service->ui_manager();
-  if (sb_ui_manager->IsUrlWhitelistedOrPendingForWebContents(
-          entry->GetURL(), false, entry, web_contents, false)) {
-    state->fails_malware_check = true;
-    state->initial_security_level = SecurityStateModel::DANGEROUS;
-  }
 }

 }  // namespace
--- ./chrome/browser/download/download_commands.cc
+++ ./chrome/browser/download/download_commands.cc.new
@@ -185,9 +185,6 @@
       // filename. Don't base an "Always open" decision based on it. Also
       // exclude extensions.
       return download_item_->CanOpenDownload() &&
-             safe_browsing::FileTypePolicies::GetInstance()
-                 ->IsAllowedToOpenAutomatically(
-                     download_item_->GetTargetFilePath()) &&
              !download_crx_util::IsExtensionDownload(*download_item_);
     case CANCEL:
       return !download_item_->IsDone();
--- ./chrome/browser/BUILD.gn
+++ ./chrome/browser/BUILD.gn.new
@@ -2590,8 +2590,6 @@ split_static_library("browser") {
       "download/download_commands.h",
       "download/download_crx_util.cc",
       "download/download_crx_util.h",
-      "download/download_danger_prompt.cc",
-      "download/download_danger_prompt.h",
       "download/download_dir_policy_handler.cc",
       "download/download_dir_policy_handler.h",
       "download/download_permission_request.cc",
--- ./chrome/browser/ui/BUILD.gn
+++ ./chrome/browser/ui/BUILD.gn.new
@@ -1618,7 +1618,6 @@ split_static_library("ui") {
         "views/constrained_web_dialog_delegate_views.cc",
         "views/create_application_shortcut_view.cc",
         "views/create_application_shortcut_view.h",
-        "views/download/download_danger_prompt_views.cc",
         "views/download/download_feedback_dialog_view.cc",
         "views/download/download_feedback_dialog_view.h",
         "views/download/download_in_progress_dialog_view.cc",
@@ -2557,7 +2556,6 @@ split_static_library("ui") {
         "cocoa/dev_tools_controller.mm",
         "cocoa/download/background_theme.h",
         "cocoa/download/background_theme.mm",
-        "cocoa/download/download_danger_prompt_impl.cc",
         "cocoa/download/download_item_button.h",
         "cocoa/download/download_item_button.mm",
         "cocoa/download/download_item_cell.h",
